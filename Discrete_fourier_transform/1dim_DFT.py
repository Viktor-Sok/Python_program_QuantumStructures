#imports module for numerical calculations
import numpy as np
#import module for scientific calculations
import scipy.linalg as la
#imports module for visualization of results
import matplotlib.pyplot as plt
from scipy import optimize
from scipy import constants
import math
from scipy.sparse import diags


#степень двойки(для эффективной работы алгоритма FFT)
t = 10
#число точек дискретизации исходной функции
N = 2**t
"""
Прямое численное преобразование Фурье
с помощью алгоритма FFT по известной функции
"""
#величина "обрезанной" оласти определения функции
l = 10
#число нулей для увеличения "разрешения" фурье образа
Zeros = 0
#массив точек исходной функции обрезанной на отрезок 2*l
x = np.linspace(-l,l,N-2*Zeros)
#шаг дискретизации по времени(координате)
d = x[1] - x[0]
f =  np.exp(-np.abs(x))
# добавление к массив функции нулей
f1 = np.block([np.zeros(Zeros), f, np.zeros(Zeros)])
# выделение куска функции при переодичсеком продолжении f1 , который лежит правее нуля, т.к. FFT  работает от нуля
f11 = f1[0:int(N/2)]
f12 = f1[int(N/2): (N)]
F = np.block([f12,f11])
# выполняем FFT
DF = np.fft.fft(F)
#Сдвиг отрицательной частотной части влево
DF = np.fft.fftshift(DF)
# переходим к соответствующему математическому образу Фурье
MDF = d*DF
#выводим соответствующие "частоты в Герцах" (в обратных длинах волн)
v = np.fft.fftfreq(N,d)
#сдвигаем отрицательные частоты влево
v = np.fft.fftshift(v)
#Переходим к "круговым частотам" (к волновым векторам)
w = 2*np.pi*v
print (MDF)
#Аналитически вычесленный Фурье образ
w1 = np.linspace(w[500],w[N-500],500)
_f_ =2/(1+(w1)**2)
# Сравнение аналитического и численного преобразований Фурье
plt.figure(1)
plt.plot(w1,_f_,color = 'b')
plt.plot(w[500:N-500],abs(MDF[500:N-500]),'x',color = 'r')
plt.title("Сравнение численно найденного ПФ с аналитическим")

"""
Обратное численное преобразование Фурье
с помощью алгоритма FFT по известному образу Фурье функции
"""
# массив точек аналитически найденного образа Фурье 
m =8
k = np.linspace(-m,m,N-2*Zeros)
g = 2/(1+k**2)
# переход от круговых частот (волновых векторов) к герцам (обратным длинам волн)

#шаг дискретизации по частоте(обратной длине волны)
h = k[1] - k[0]
# добавление к массив Фурье образа нулей для лучшего "разрешения" оригинала при FFT
g1 = np.block([np.zeros(Zeros), g, np.zeros(Zeros)])
# переодическое продолжение g, т.к. алгоритм FFT берёт преобразование от нулевой частоты
# т.е. правильное упорядочивание значений Фурье образа в соответствии с порядком частот у алгоритма FFT
g11 = g1[0:int(N/2)]
g12 = g1[int(N/2): (N)]
G = np.block([g12,g11])
#Выполняем обратное DPF  алгоритмом FFT
IG = np.fft.ifft(G)
#Сдвиг отрицательной временной(координатной) части влево
IG = np.fft.fftshift(IG)
# переходим к соответствующему математическому обратному преобразованию Фурье
MIG = N*h*IG/(2*np.pi)
#выводим соответствующие времена (координаты)
X = np.fft.fftfreq(N,h)
#сдвигаем отрицательные координаты влево
X = np.fft.fftshift(X)
#Переходим к "круговым частотам" (к волновым векторам)
X1 = 2*np.pi*X
#print (MDF)
#Аналитическая исходная функция
X2 = np.linspace(X1[500],X1[N-500],500)
z =  np.exp(-np.abs(X2))
plt.figure(2)
plt.plot(X2,z,color = 'b')
plt.plot(X1[500:N-500],abs(MIG[500:N-500]),'x',color = 'r')
plt.title("Сравнение численно найденного обратного ПФ с исходной функцией")
plt.show()



#Fg = np.fft.ifft(g)


